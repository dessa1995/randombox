<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
    <title>랜덤 게임 만들기</title>
    <style>
        /* --- 폰트 및 기본 스타일 --- */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root{
            --bg-color:#FDF6E3;
            --primary-color:#657B83;
            --accent-color:#D33682;
            --font-color:#073642;
            --highlight-blue:#268BD2;
            --highlight-green:#859900;
            --container-bg:rgba(255,255,255,.8);
            --shadow-color:rgba(0,0,0,.15);
        }
        *{box-sizing:border-box;margin:0;padding:0}
        html,body{
            width:100%;height:100%;
            background:var(--bg-color);
            color:var(--font-color);
            font-family:'Press Start 2P',cursive;
            overflow:hidden;display:flex;justify-content:center;align-items:center;text-align:center;
        }

        /* --- 화면 관리 --- */
        .screen{display:none;flex-direction:column;justify-content:center;align-items:center;width:100%;height:100%;padding:10px;animation:fadeIn .5s ease-in-out;position:absolute}
        .screen.active{display:flex}
        @keyframes fadeIn{from{opacity:0;transform:scale(.98)}to{opacity:1;transform:scale(1)}}
        @keyframes title-glow{0%,100%{text-shadow:2px 2px 0 var(--highlight-blue)}50%{text-shadow:2px 2px 0 var(--accent-color)}}
        @keyframes sparkle{0%{box-shadow:0 0 15px var(--highlight-blue)}50%{box-shadow:0 0 25px var(--accent-color)}100%{box-shadow:0 0 15px var(--highlight-blue)}}

        /* --- 공통 컴포넌트 --- */
        h1{font-size:clamp(1.5rem,5vw,2rem);color:var(--font-color);margin-bottom:20px;animation:title-glow 3s ease-in-out infinite}
        .pixel-button{
            font-family:'Press Start 2P',cursive;background:var(--primary-color);color:#fff;border:3px solid var(--font-color);
            padding:10px 20px;font-size:clamp(.8rem,2.5vw,1rem);cursor:pointer;position:relative;box-shadow:4px 4px 0 var(--shadow-color);
            transition:all .1s ease-out;margin:5px;-webkit-tap-highlight-color:transparent
        }
        .pixel-button:hover{transform:translate(1px,1px);box-shadow:3px 3px 0 var(--shadow-color)}
        .pixel-button:active{transform:translate(2px,2px);box-shadow:2px 2px 0 var(--shadow-color)}
        .pixel-button:disabled{background:#93A1A1;cursor:not-allowed;box-shadow:none;transform:none}

        .game-container{
            border:4px solid var(--font-color);padding:15px;width:95%;max-width:600px;background:var(--container-bg);
            display:flex;flex-direction:column;align-items:center;max-height:95vh;overflow-y:auto;border-radius:8px
        }
        .input-group{margin:10px 0;width:100%}
        label{display:block;margin-bottom:8px;font-size:.8rem}
        input[type="text"],input[type="number"]{
            font-family:'Press Start 2P',cursive;width:100%;padding:8px;background:#EEE8D5;border:2px solid var(--primary-color);color:var(--font-color);font-size:.7rem;border-radius:4px
        }
        input[type="range"]{-webkit-appearance:none;appearance:none;width:100%;height:10px;background:#EEE8D5;border:2px solid var(--primary-color);border-radius:5px;outline:none;opacity:.7;transition:opacity .2s}
        input[type="range"]:hover{opacity:1}
        input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:20px;height:20px;background:var(--highlight-blue);border:2px solid var(--font-color);cursor:pointer;border-radius:50%}
        input[type="range"]::-moz-range-thumb{width:20px;height:20px;background:var(--highlight-blue);border:2px solid var(--font-color);cursor:pointer;border-radius:50%}

        .dynamic-input-container{width:90%;max-height:150px;overflow-y:auto;padding-right:5px}
        .input-row{display:flex;align-items:center;margin-bottom:8px}
        .input-row input{flex-grow:1}
        .remove-button,.add-input-button{
            background:var(--accent-color);border:2px solid var(--font-color);color:#fff;font-family:'Press Start 2P',cursive;cursor:pointer;margin-left:10px;padding:5px 10px;font-size:.8rem;border-radius:4px
        }
        .add-input-button{background:var(--highlight-blue)}

        /* --- 모달 --- */
        .modal-overlay{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);justify-content:center;align-items:center;z-index:2000;padding:20px}
        .modal-content{
            background:var(--bg-color);border:4px solid var(--font-color);padding:20px;text-align:left;position:relative;max-width:600px;width:100%;
            max-height:80vh;overflow-y:auto;font-size:.8rem;line-height:1.6
        }
        .modal-close-button{position:absolute;top:10px;right:15px;font-size:1.5rem;color:var(--font-color);cursor:pointer;background:none;border:none}
        .modal-content h3,#result-modal-content h2{color:var(--highlight-blue);margin:10px 0;text-align:center}
        .modal-content ul{list-style:square;padding-left:20px}

        /* --- 게임별 스타일 --- */
        .game-canvas{
            background:#EEE8D5;border:2px solid var(--primary-color);box-shadow:3px 3px 8px var(--shadow-color);
            max-width:100%;display:block;border-radius:8px;cursor:pointer
        }
        #roulette-result,#drawing-status,#ladder-status, #number-picker-result{margin-top:15px;font-size:1rem;color:var(--accent-color);min-height:25px}
        .radio-group label{display:inline-block;margin:5px 10px;font-size:.8rem}
        #ladder-options{display:none}

        /* 뽑기 */
        #envelopes-container{display:flex;flex-wrap:wrap;justify-content:center;gap:10px;margin-top:15px;width:100%}
        .envelope{
            width:80px;height:60px;background:var(--highlight-blue);border:3px solid var(--font-color);border-radius:8px;cursor:pointer;display:flex;justify-content:center;align-items:center;
            font-size:1.5rem;color:#fff;transition:transform .2s
        }
        .envelope:hover{transform:scale(1.1)}
        .envelope.opened{background:var(--accent-color);cursor:not-allowed;font-size:.7rem;padding:5px;word-break:break-all}
        .envelope.sparkle{animation:sparkle .5s 2}
        #result-modal-body{font-size:1.2rem;line-height:1.8;text-align:center;text-shadow:1px 1px 2px var(--shadow-color)}

        /* --- 사용 설명 버튼 --- */
        #how-to-play-button{position:fixed;bottom:15px;right:15px;z-index:1000;width:45px;height:45px;border-radius:50%;font-size:1.2rem;padding:0;line-height:45px;text-align:center}
    </style>
</head>
<body>
    <!-- 메인 메뉴 -->
    <div id="main-menu" class="screen active">
        <h1>랜덤 게임 월드</h1>
        <div>
            <button class="pixel-button" data-screen="roulette-screen">룰렛</button>
            <button class="pixel-button" data-screen="ladder-screen">사다리타기</button>
            <button class="pixel-button" data-screen="drawing-screen">뽑기</button>
            <button class="pixel-button" data-screen="number-picker-screen">숫자 뽑기</button>
        </div>
    </div>

    <!-- 룰렛 -->
    <div id="roulette-screen" class="screen">
        <div class="game-container">
            <h1>룰렛</h1>
            <canvas id="roulette-canvas" class="game-canvas"></canvas>
            <div id="roulette-result"></div>
            <div class="input-group">
                <label>항목</label>
                <div id="roulette-items-container" class="dynamic-input-container"></div>
                <button class="pixel-button add-input-button" data-container="roulette-items-container">+</button>
            </div>
            <div class="input-group">
                <label for="roulette-speed">회전 속도</label>
                <input type="range" id="roulette-speed" min="1" max="10" value="5">
            </div>
            <button class="pixel-button" id="generate-roulette-button">룰렛 생성</button>
            <button class="pixel-button" id="spin-button" style="display:none;">돌리기!</button>
            <button class="pixel-button back-button">뒤로가기</button>
        </div>
    </div>
    <!-- 사다리 -->
    <div id="ladder-screen" class="screen">
        <div class="game-container">
            <h1>사다리타기</h1>
            <canvas id="ladder-canvas" class="game-canvas"></canvas>
            <div id="ladder-status"></div>
            <div class="input-group">
                <label>이름</label>
                <div id="ladder-names-container" class="dynamic-input-container"></div>
                <button class="pixel-button add-input-button" data-container="ladder-names-container">+</button>
            </div>
            <div class="input-group radio-group">
                <label><input type="radio" name="ladder-mode" value="rank" checked> 순위 정하기</label>
                <label><input type="radio" name="ladder-mode" value="dud"> 꽝 찾기</label>
                <label><input type="radio" name="ladder-mode" value="winner"> 당첨자 찾기</label>
            </div>
            <div id="ladder-options" class="input-group">
                <label for="ladder-option-count" id="ladder-option-label">꽝 개수</label>
                <input type="number" id="ladder-option-count" value="1" min="1">
            </div>
            <div class="input-group">
                <label for="ladder-complexity">사다리 복잡도: <span id="ladder-complexity-value">3</span> (1-5)</label>
                <input type="range" id="ladder-complexity" min="1" max="5" value="3">
            </div>
            <button class="pixel-button" id="ladder-generate-button">사다리 생성</button>
            <button class="pixel-button" id="ladder-result-button" style="display:none;">결과 보기</button>
            <button class="pixel-button back-button">뒤로가기</button>
        </div>
    </div>

    <!-- 뽑기 -->
    <div id="drawing-screen" class="screen">
        <div class="game-container">
            <h1>뽑기</h1>
            <div id="drawing-status"></div>
            <div id="envelopes-container"></div>
            <div class="input-group">
                <label>참가자</label>
                <div id="drawing-participants-container" class="dynamic-input-container"></div>
                <button class="pixel-button add-input-button" data-container="drawing-participants-container">+</button>
            </div>
            <div class="input-group">
                <label for="drawing-count">뽑을 갯수</label>
                <input type="number" id="drawing-count" value="1" min="1">
            </div>
            <div class="input-group radio-group">
                <label><input type="checkbox" id="allow-duplicates"> 중복 뽑기 허용</label>
            </div>
            <button class="pixel-button" id="generate-envelopes-button">뽑기판 생성!</button>
            <button class="pixel-button" id="drawing-result-button" style="display:none;">결과 보기</button>
            <button class="pixel-button back-button">뒤로가기</button>
        </div>
    </div>
    
    <!-- 랜덤 숫자 뽑기 -->
    <div id="number-picker-screen" class="screen">
        <div class="game-container">
            <h1>랜덤 숫자 뽑기</h1>
            <canvas id="number-picker-canvas" class="game-canvas"></canvas>
            <div id="number-picker-result"></div>
            <div class="input-group radio-group">
                <label><input type="radio" name="number-mode" value="range" checked> 범위로 입력</label>
                <label><input type="radio" name="number-mode" value="direct"> 직접 입력</label>
            </div>
            <div class="input-group" id="number-range-container">
                <label for="number-range-input">숫자 범위 (예: 1-45, 50-60)</label>
                <input type="text" id="number-range-input" placeholder="1-45">
            </div>
            <div class="input-group" id="number-direct-container" style="display: none;">
                 <label for="number-direct-input">숫자 직접 입력 (쉼표/공백으로 구분)</label>
                 <input type="text" id="number-direct-input" placeholder="7, 13, 21, 35">
            </div>
            <button class="pixel-button" id="generate-numbers-button">숫자판 생성</button>
            <button class="pixel-button" id="pick-number-button" style="display:none;">뽑기!</button>
            <button class="pixel-button back-button">뒤로가기</button>
        </div>
    </div>

    <!-- 사용 설명 모달 -->
    <button id="how-to-play-button" class="pixel-button">?</button>
    <div id="how-to-play-modal" class="modal-overlay">
        <div id="modal-content" class="modal-content">
            <button id="modal-close" class="modal-close-button">X</button>
            <h2>사용 설명</h2>
            <h3>룰렛</h3>
            <ul>
                <li>'+' 버튼으로 항목을 추가하고 '룰렛 생성' 버튼을 누르세요.</li>
                <li>'돌리기!' 버튼으로 룰렛을 실행합니다.</li>
                <li>애니메이션 중 화면을 클릭하면 즉시 결과가 나옵니다.</li>
            </ul>
            <h3>사다리타기</h3>
            <ul>
                <li>'+' 버튼으로 이름을 추가하고 '사다리 생성' 버튼을 누르세요.</li>
                <li>복잡도를 조절하여 가로줄의 수를 변경할 수 있습니다.</li>
                <li>상단 이름을 클릭하면 한 명씩 결과 확인이 가능합니다.</li>
                <li>'결과 보기' 버튼으로 모든 결과를 한 번에 확인할 수 있습니다.</li>
            </ul>
            <h3>뽑기</h3>
            <ul>
                <li>참가자와 뽑을 갯수 등을 설정하고 '뽑기판 생성'을 누르세요.</li>
                <li>생성된 봉투를 클릭하여 결과를 확인하세요.</li>
            </ul>
            <h3>랜덤 숫자 뽑기</h3>
            <ul>
                <li>'범위로 입력' 또는 '직접 입력'을 선택하고 숫자를 입력하세요.</li>
                <li>'숫자판 생성' 버튼을 눌러 공을 생성합니다.</li>
                <li>'뽑기!' 버튼을 누르면 애니메이션 후 숫자가 추첨됩니다.</li>
            </ul>
            <h3>결과 캡처하기</h3>
            <ul>
                <li><strong>Windows:</strong> Win + Shift + S</li>
                <li><strong>macOS:</strong> Cmd + Shift + 4</li>
                <li><strong>Android:</strong> 볼륨 아래 + 전원 버튼</li>
                <li><strong>iOS:</strong> 측면 + 볼륨 위 버튼</li>
            </ul>
        </div>
    </div>

    <!-- 결과 요약 모달 -->
    <div id="result-modal" class="modal-overlay">
        <div id="result-modal-content" class="modal-content">
            <button id="result-modal-close" class="modal-close-button">X</button>
            <h2 id="result-modal-title">게임 결과</h2>
            <div id="result-modal-body"></div>
        </div>
    </div>
    <script>
        /* ---------- 캔버스 색상 ---------- */
        const CSS = getComputedStyle(document.documentElement);
        const COLORS = {
            font: (CSS.getPropertyValue('--font-color')||'#073642').trim(),
            primary: (CSS.getPropertyValue('--primary-color')||'#657B83').trim(),
            accent: (CSS.getPropertyValue('--accent-color')||'#D33682').trim(),
            blue: (CSS.getPropertyValue('--highlight-blue')||'#268BD2').trim()
        };
        const PURE_BLACK = "#000000";
        const PURE_WHITE = "#ffffff";

        const ROULETTE_COLORS = ["#268BD2","#D33682","#859900","#2AA198","#B58900","#CB4B16","#6C71C4"];

        /* --- 공통 화면 전환 & 모달 --- */
        const screens=document.querySelectorAll('.screen');
        const backButtons=document.querySelectorAll('.back-button');
        const howToPlayModal=document.getElementById('how-to-play-modal');
        const resultModal=document.getElementById('result-modal');
        const howToPlayButton=document.getElementById('how-to-play-button');

        function showScreen(id){
            screens.forEach(s=>s.classList.remove('active'));
            const el=document.getElementById(id);
            if(el){
                el.classList.add('active');
                if(id==='roulette-screen') initRoulette();
                if(id==='ladder-screen') initLadder();
                if(id==='drawing-screen') initDrawing();
                if(id==='number-picker-screen') initNumberPicker();
            }
            resizeCanvases();
        }
        document.getElementById('main-menu').addEventListener('click',e=>{
            if(e.target.matches('.pixel-button[data-screen]')) showScreen(e.target.dataset.screen);
        });
        backButtons.forEach(btn=>btn.addEventListener('click',()=>showScreen('main-menu')));

        function setupModal(modal, openBtn, closeBtnSelector){
            const closeBtn=modal.querySelector(closeBtnSelector);
            if(openBtn) openBtn.addEventListener('click',()=>modal.style.display='flex');
            closeBtn.addEventListener('click',()=>modal.style.display='none');
            modal.addEventListener('click',e=>{ if(e.target===modal) modal.style.display='none'; });
        }
        setupModal(howToPlayModal,howToPlayButton,'#modal-close');
        setupModal(resultModal,null,'#result-modal-close');

        function showResultModal(title,results){
            document.getElementById('result-modal-title').textContent=title;
            const body=document.getElementById('result-modal-body');
            body.innerHTML=Array.isArray(results)?results.join('<br>'):results;
            resultModal.style.display='flex';
        }

        /* --- 동적 입력 관리 --- */
        function createDynamicInputs(containerId, initialCount=2){
            const container=document.getElementById(containerId);
            container.innerHTML='';
            for(let i=0;i<initialCount;i++) addInputRow(container,`항목 ${i+1}`);
        }
        function addInputRow(container, placeholder=''){
            const row=document.createElement('div');
            row.className='input-row';
            row.innerHTML=`<input type="text" placeholder="${placeholder}" value=""><button class="remove-button">-</button>`;
            container.appendChild(row);
        }
        document.body.addEventListener('click',e=>{
            if(e.target.classList.contains('add-input-button')){
                const container=document.getElementById(e.target.dataset.container);
                addInputRow(container,`항목 ${container.children.length+1}`);
            }
            if(e.target.classList.contains('remove-button')){
                const row=e.target.parentElement;
                if(row.parentElement.children.length>2) row.remove();
                else showResultModal('오류','항목은 최소 2개 이상이어야 합니다.');
            }
        });

        function getDynamicInputValues(containerId){
            const container=document.getElementById(containerId);
            return Array.from(container.querySelectorAll('input[type="text"]'))
                .map(i=>i.value.trim()||i.placeholder.trim())
                .filter(v=>v!=='');
        }

        /* ---------------- 룰렛 ---------------- */
        const rouletteCanvas=document.getElementById('roulette-canvas');
        const rCtx=rouletteCanvas.getContext('2d');
        const generateRouletteButton=document.getElementById('generate-roulette-button');
        const spinButton=document.getElementById('spin-button');
        const rouletteResultEl=document.getElementById('roulette-result');
        const rouletteSpeedSlider=document.getElementById('roulette-speed');
        let rouletteAngle=0, rouletteSpinning=false, rouletteItems=[], rouletteSkip=false;

        function drawRoulette(){
            const n=rouletteItems.length;
            const dpr=window.devicePixelRatio||1;
            const cx=rouletteCanvas.width/dpr/2, cy=rouletteCanvas.height/dpr/2;
            rCtx.clearRect(0,0,rouletteCanvas.width,rouletteCanvas.height);

            rCtx.font="12px 'Press Start 2P'";
            rCtx.textAlign='center';
            rCtx.fillStyle=COLORS.font;

            if(n<2){
                rCtx.fillText("항목 입력 후 생성",cx,cy-10);
                rCtx.fillText("버튼을 누르세요",cx,cy+15);
                return;
            }

            const arc=2*Math.PI/n;
            const radius=Math.min(cx,cy)*0.9;

            for(let i=0;i<n;i++){
                const ang=rouletteAngle+i*arc;
                rCtx.beginPath();
                rCtx.fillStyle=ROULETTE_COLORS[i%ROULETTE_COLORS.length];
                rCtx.moveTo(cx,cy);
                rCtx.arc(cx,cy,radius,ang,ang+arc);
                rCtx.closePath();
                rCtx.fill();

                rCtx.save();
                rCtx.fillStyle=PURE_WHITE;
                rCtx.translate(cx+Math.cos(ang+arc/2)*radius*0.6, cy+Math.sin(ang+arc/2)*radius*0.6);
                rCtx.rotate(ang+arc/2+Math.PI/2);
                const text=rouletteItems[i].length>7?rouletteItems[i].substring(0,6)+'...':rouletteItems[i];
                rCtx.fillText(text,0,0);
                rCtx.restore();
            }

            rCtx.fillStyle=COLORS.font;
            rCtx.beginPath();
            rCtx.moveTo(cx+radius-5,cy);
            rCtx.lineTo(cx+radius+15,cy-10);
            rCtx.lineTo(cx+radius+15,cy+10);
            rCtx.closePath();
            rCtx.fill();
        }

        function generateRoulette(){
            rouletteItems=getDynamicInputValues('roulette-items-container');
            if(rouletteItems.length<2){ showResultModal('오류','항목을 2개 이상 입력해주세요.'); return; }
            rouletteAngle=0; drawRoulette();
            spinButton.style.display='inline-block';
            generateRouletteButton.textContent='재생성';
            rouletteResultEl.textContent='';
        }

        function spinAnimation(){
            if(rouletteSpinning) return;
            rouletteSpinning=true; rouletteSkip=false;
            rouletteResultEl.textContent='...';
            spinButton.disabled=true; generateRouletteButton.disabled=true;

            const speed=rouletteSpeedSlider.value;
            const spinAngleTotal=Math.random()*10+10*speed;
            let start=null;

            function animate(ts){
                if(!start) start=ts;
                const progress=ts-start, duration=3000;
                const easeOut=1-Math.pow(1-Math.min(progress/duration,1),3);
                rouletteAngle=(spinAngleTotal*easeOut)%(2*Math.PI);
                drawRoulette();

                if(progress<duration && !rouletteSkip) requestAnimationFrame(animate);
                else{
                    rouletteSpinning=false;
                    const finalAngle=rouletteSkip?(spinAngleTotal%(2*Math.PI)):rouletteAngle;
                    const arc=2*Math.PI/rouletteItems.length;
                    const idx=Math.floor(((2*Math.PI-finalAngle+Math.PI/2)%(2*Math.PI))/arc);
                    const item=rouletteItems[idx];
                    rouletteResultEl.textContent=`결과: ${item}`;
                    spinButton.disabled=false; generateRouletteButton.disabled=false;
                    showResultModal('룰렛 결과',`🎉 ${item} 🎉`);
                }
            }
            requestAnimationFrame(animate);
        }
        function initRoulette(){
            createDynamicInputs('roulette-items-container');
            rouletteItems=[]; drawRoulette();
            spinButton.style.display='none';
            generateRouletteButton.textContent='룰렛 생성';
            rouletteResultEl.textContent='';
        }
        generateRouletteButton.addEventListener('click',generateRoulette);
        spinButton.addEventListener('click',spinAnimation);

        /* ---------------- 사다리 ---------------- */
        const ladderCanvas=document.getElementById('ladder-canvas');
        const lCtx=ladderCanvas.getContext('2d');
        const ladderGenerateBtn=document.getElementById('ladder-generate-button');
        const ladderResultBtn=document.getElementById('ladder-result-button');
        const ladderOptionsEl=document.getElementById('ladder-options');
        const ladderOptionLabelEl=document.getElementById('ladder-option-label');
        const ladderOptionCountEl=document.getElementById('ladder-option-count');
        const ladderStatusEl=document.getElementById('ladder-status');
        const ladderComplexitySlider=document.getElementById('ladder-complexity');
        const ladderComplexityValue=document.getElementById('ladder-complexity-value');

        let ladderData={}, animationSkipped=false, tracing=false, sparkles=[];

        ladderComplexitySlider.addEventListener('input',e=>{ ladderComplexityValue.textContent=e.target.value; });

        function generateLadder(){
            const names=getDynamicInputValues('ladder-names-container');
            const mode=document.querySelector('input[name="ladder-mode"]:checked').value;
            const count=parseInt(ladderOptionCountEl.value);
            const complexity=parseInt(ladderComplexitySlider.value);

            if(names.length<2){ showResultModal('오류','이름을 2개 이상 입력해주세요.'); return; }
            if((mode==='dud'||mode==='winner') && (count>=names.length || count<1)){
                showResultModal('오류','꽝/당첨자 수는 1개 이상, 전체 이름 수보다 적어야 합니다.'); return;
            }

            let results=[];
            if(mode==='rank'){ for(let i=1;i<=names.length;i++) results.push(`${i}등`); }
            else{
                const main=(mode==='dud')?'꽝':'당첨';
                const sub =(mode==='dud')?'통과':'꽝';
                for(let i=0;i<names.length;i++) results.push(i<count?main:sub);
                results.sort(()=>Math.random()-0.5);
            }

            ladderData={ names, results, paths:[], connections:[], revealed:new Set(), summary:[] };

            const width=ladderCanvas.width/(window.devicePixelRatio||1);
            const height=ladderCanvas.height/(window.devicePixelRatio||1);
            const num=names.length;
            const yMargin=height*0.15;
            const ladderHeight=height*0.7;

            for(let i=0;i<num;i++) ladderData.connections.push({from:i,to:i});

            // --- 사다리 생성 로직 개선 ---
            const rungPositions = new Set();
            const minVGap = 25;

            // 1. 모든 세로줄이 연결되도록 최소한의 가로줄 생성
            const backbone = Array.from({length: num - 1}, (_, i) => i);
            for (let i = backbone.length - 1; i > 0; i--) { // Shuffle
                const j = Math.floor(Math.random() * (i + 1));
                [backbone[i], backbone[j]] = [backbone[j], backbone[i]];
            }
            
            backbone.forEach(from => {
                 let y1, attempts = 0;
                 do {
                     y1 = yMargin + Math.random() * ladderHeight;
                     attempts++;
                 } while (Array.from(rungPositions).some(y => Math.abs(y - y1) < minVGap) && attempts < 100);
                 
                 if (attempts < 100) {
                     rungPositions.add(y1);
                     const y2 = y1 + (Math.random() - 0.5) * 20;
                     ladderData.paths.push({y1, y2, from, to: from + 1});
                 }
            });

            // 2. 복잡도에 따라 추가 가로줄 생성
            const extraRungCount = Math.max(0, (num * complexity) - (num - 1));
            for(let i = 0; i < extraRungCount; i++) {
                let y1, attempts = 0;
                do {
                     y1 = yMargin + Math.random() * ladderHeight;
                     attempts++;
                 } while (Array.from(rungPositions).some(y => Math.abs(y - y1) < minVGap) && attempts < 100);

                if (attempts < 100) {
                     rungPositions.add(y1);
                     const from = Math.floor(Math.random()*(num-1));
                     const y2 = y1 + (Math.random() - 0.5) * 20;
                     ladderData.paths.push({y1, y2, from, to: from + 1});
                 }
            }
            // --- 로직 개선 끝 ---

            ladderData.connections.forEach(c=>c.to=c.from);
            [...ladderData.paths].sort((a,b)=>a.y1-b.y1).forEach(p=>{
                const c1=ladderData.connections.find(c=>c.to===p.from);
                const c2=ladderData.connections.find(c=>c.to===p.to);
                [c1.to,c2.to]=[c2.to,c1.to];
            });

            drawLadder();
            ladderStatusEl.textContent='이름을 클릭해서 결과를 확인하세요!';
            ladderResultBtn.style.display='inline-block';
            ladderCanvas.style.cursor='pointer';
        }

        function drawLadder(){
            const dpr=window.devicePixelRatio||1;
            const width=ladderCanvas.width/dpr;
            const height=ladderCanvas.height/dpr;
            lCtx.clearRect(0,0,ladderCanvas.width,ladderCanvas.height);

            if(!ladderData.names || ladderData.names.length<2){
                lCtx.save();
                lCtx.font="12px 'Press Start 2P'";
                lCtx.textAlign='center';
                lCtx.fillStyle=COLORS.font;
                lCtx.fillText("이름 입력 후 생성",width/2,height/2-10);
                lCtx.fillText("버튼을 누르세요",width/2,height/2+15);
                lCtx.restore();
                return;
            }

            const num = ladderData.names.length;
            const fontSize = Math.max(8, Math.min(14, 18 - num));
            const textPadding = fontSize + 15;
            const spacing = width / num;

            // 세로줄
            lCtx.lineWidth=4;
            lCtx.strokeStyle=COLORS.primary;
            for(let i=0;i<num;i++){
                const x=spacing*(i+0.5);
                lCtx.beginPath();
                lCtx.moveTo(x,textPadding+15);
                lCtx.lineTo(x,height-textPadding-15);
                lCtx.stroke();
            }
            ladderData.paths.forEach(p=>{
                const x1=spacing*(p.from+0.5), x2=spacing*(p.to+0.5);
                lCtx.beginPath();
                lCtx.moveTo(x1,p.y1); lCtx.lineTo(x2,p.y2); lCtx.stroke();
            });

            // 상단 이름
            lCtx.font=`${fontSize}px 'Press Start 2P'`;
            lCtx.textAlign='center';
            lCtx.fillStyle=PURE_BLACK;
            for(let i=0;i<num;i++){
                const x=spacing*(i+0.5);
                lCtx.fillText(ladderData.names[i],x,textPadding);
            }

            // 하단 결과
            lCtx.font=`${fontSize}px 'Press Start 2P'`;
            lCtx.textAlign='center';
            for(let i=0;i<num;i++){
                const x=spacing*(i+0.5), resultY=height-textPadding+10;
                
                // --- ??? 박스 겹침 문제 해결 ---
                if(ladderData.revealed.has(i)){
                    const resultText = ladderData.results[i];
                    const textWidth = lCtx.measureText(resultText).width;
                    const boxHeight = fontSize + 14;
                    // 결과 텍스트를 그리기 전에 해당 영역을 배경색으로 덮어씌움
                    lCtx.fillStyle = '#EEE8D5'; 
                    lCtx.fillRect(x - (textWidth + 24)/2, resultY - boxHeight + 3, textWidth + 24, boxHeight);
                    
                    lCtx.fillStyle=PURE_BLACK;
                    lCtx.fillText(resultText, x, resultY);
                }else{
                    lCtx.fillStyle=PURE_BLACK;
                    const tw=lCtx.measureText('???').width;
                    const boxW=tw+24, boxH=fontSize + 14;
                    lCtx.fillRect(x-boxW/2,resultY-boxH+5,boxW,boxH);
                    lCtx.fillStyle=PURE_WHITE;
                    lCtx.fillText('???',x,resultY);
                }
                // --- 문제 해결 끝 ---
            }

            updateAndDrawLadderSparkles();
        }

        function updateAndDrawLadderSparkles() {
            for (let i = sparkles.length - 1; i >= 0; i--) {
                const p = sparkles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.size *= 0.98;

                if (p.life <= 0 || p.size < 0.5) {
                    sparkles.splice(i, 1);
                    continue;
                }

                lCtx.save();
                lCtx.globalAlpha = p.life / p.initialLife;
                lCtx.beginPath();
                lCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2, false);
                lCtx.fillStyle = p.color;
                lCtx.shadowColor = p.color;
                lCtx.shadowBlur = 15;
                lCtx.fill();
                lCtx.restore();
            }
        }

        function tracePath(startIndex){
            if(tracing) return;
            tracing=true; animationSkipped=false; sparkles=[];

            const dpr=window.devicePixelRatio||1;
            const width=ladderCanvas.width/dpr, height=ladderCanvas.height/dpr;
            const num=ladderData.names.length;
            const spacing=width/num;
            const fontSize = Math.max(8, Math.min(14, 18 - num));
            const textPadding = fontSize + 15;

            let current=startIndex, currentY=textPadding+15;
            const points=[{x:spacing*(current+0.5), y:currentY}];
            const rungs=[...ladderData.paths].sort((a, b) => a.y1 - b.y1);

            while(true){
                let next=null, nextIdx=-1;
                for(let i=0;i<rungs.length;i++){
                     const r = rungs[i];
                    if (r.from === current || r.to === current) {
                        const startY = (r.from === current) ? r.y1 : r.y2;
                        if (startY >= currentY - 0.1) { // Epsilon for floating point
                           next = r;
                           nextIdx = i;
                           break; 
                        }
                    }
                }
                
                if(next){
                    const r = rungs.splice(nextIdx, 1)[0];
                    const isMovingFromLeft = r.from === current;
                    const startY = isMovingFromLeft ? r.y1 : r.y2;
                    const endY = isMovingFromLeft ? r.y2 : r.y1;
                    
                    points.push({x:spacing*(current+0.5), y:startY});
                    current=(r.from===current)?r.to:r.from;
                    points.push({x:spacing*(current+0.5), y:endY});
                    currentY=endY;
                }else break;
            }
            points.push({x:spacing*(current+0.5), y:height-textPadding-15});
            const resultIndex=current;

            let start=null;
            let pathTraceComplete = false;
            function animate(t){
                if(!start) start=t;
                let prog=Math.min((t-start)/1500,1); // Faster animation
                if(animationSkipped) prog=1;

                if (prog < 1) {
                    const pointIdx = prog * (points.length - 1);
                    const idx = Math.floor(pointIdx);
                    const segmentProg = pointIdx - idx;
                    const p1 = points[idx];
                    const p2 = points[Math.min(idx + 1, points.length - 1)];
                    const x = p1.x + (p2.x - p1.x) * segmentProg;
                    const y = p1.y + (p2.y - p1.y) * segmentProg;

                    for (let i = 0; i < 4; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 2.5 + 0.5;
                        const life = Math.random() * 50 + 30;
                        sparkles.push({
                            x, y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            size: Math.random() * 5 + 5,
                            color: `hsl(${195 + Math.random() * 30}, 100%, 70%)`,
                            life: life,
                            initialLife: life
                        });
                    }
                } else if (!pathTraceComplete) {
                    pathTraceComplete = true;
                    ladderData.revealed.add(resultIndex);
                    ladderData.summary[startIndex]=`${ladderData.names[startIndex]}: ${ladderData.results[resultIndex]}`;
                    ladderResultBtn.style.display='inline-block';
                }
                
                drawLadder();

                if(prog < 1 || sparkles.length > 0) {
                    requestAnimationFrame(animate);
                } else {
                    tracing = false;
                    if(ladderData.revealed.size===ladderData.names.length){
                        ladderStatusEl.textContent='모든 결과를 확인했습니다!';
                        showResultModal('사다리타기 전체 결과',ladderData.summary.filter(Boolean));
                    }
                }
            }
            requestAnimationFrame(animate);
        }
        function initLadder(){
            createDynamicInputs('ladder-names-container',3);
            ladderData={}; drawLadder();
            ladderStatusEl.textContent=''; ladderResultBtn.style.display='none';
        }
        document.getElementById('ladder-generate-button').addEventListener('click',generateLadder);
        ladderResultBtn.addEventListener('click',()=>{
            if(!ladderData.names || tracing) return;
            for(let i=0;i<ladderData.names.length;i++){
                const resultIndex=ladderData.connections.find(c => c.from === i).to;
                ladderData.revealed.add(resultIndex);
                ladderData.summary[i]=`${ladderData.names[i]}: ${ladderData.results[resultIndex]}`;
            }
            drawLadder();
            showResultModal('사다리타기 전체 결과',ladderData.summary.filter(Boolean));
            ladderStatusEl.textContent='전체 결과 확인 완료!';
            ladderCanvas.style.cursor='default';
        });

        ladderCanvas.addEventListener('click',e=>{
            if(!ladderData.names || ladderData.revealed.size===ladderData.names.length) return;
            if(tracing){ animationSkipped=true; return; }
            const rect=ladderCanvas.getBoundingClientRect();
            const x=e.clientX-rect.left, y=e.clientY-rect.top;
            const num=ladderData.names.length;
            const spacing=ladderCanvas.clientWidth/num;
            const fontSize = Math.max(8, Math.min(14, 18 - num));
            const textPadding = fontSize + 15;
            if(y < textPadding * 2){ // Increase clickable area
                const idx=Math.floor(x/spacing);
                if(idx>=0 && idx<num) tracePath(idx);
            }
        });

        /* ---------------- 뽑기 ---------------- */
        const generateEnvelopesBtn=document.getElementById('generate-envelopes-button');
        const envelopesContainer=document.getElementById('envelopes-container');
        const drawingStatusEl=document.getElementById('drawing-status');
        const drawingResultBtn=document.getElementById('drawing-result-button');
        let drawingState={}, drawCount=1;

        function initDrawing(){
            createDynamicInputs('drawing-participants-container');
            envelopesContainer.innerHTML='';
            drawingStatusEl.textContent='참가자를 입력하고 뽑기판을 생성하세요.';
            drawingResultBtn.style.display='none';
        }

        generateEnvelopesBtn.addEventListener('click',()=>{
            const participants=getDynamicInputValues('drawing-participants-container');
            const totalDraws=parseInt(document.getElementById('drawing-count').value);
            const allowDuplicates=document.getElementById('allow-duplicates').checked;

            if(participants.length<2 || totalDraws<1){
                showResultModal('오류','참가자는 2명 이상, 뽑을 갯수는 1개 이상이어야 합니다.');
                return;
            }
            if(!allowDuplicates && totalDraws>participants.length){
                showResultModal('오류','중복 뽑기 비허용 시, 뽑을 갯수는 참가자 수보다 많을 수 없습니다.');
                return;
            }

            drawingState={
                participants:[...participants],
                available:[...participants],
                totalDraws,
                allowDuplicates,
                drawsLeft:totalDraws,
                summary:[]
            };
            drawCount=1;

            envelopesContainer.innerHTML='';
            participants.forEach(()=>{
                const env=document.createElement('div');
                env.className='envelope';
                env.textContent='?';
                envelopesContainer.appendChild(env);
            });
            drawingStatusEl.textContent=`봉투를 클릭하세요! (남은 횟수: ${drawingState.drawsLeft})`;
            drawingResultBtn.style.display='none';
        });

        envelopesContainer.addEventListener('click',e=>{
            const env=e.target.closest('.envelope');
            if(!env || env.classList.contains('opened') || env.classList.contains('is-opening')) return;
            if(drawingState.drawsLeft<=0){
                showResultModal('안내','모든 뽑기를 완료했습니다.');
                return;
            }

            env.classList.add('sparkle','is-opening');
            setTimeout(()=>{
                env.classList.remove('sparkle');
                if(drawingState.available.length===0 && !drawingState.allowDuplicates) return;

                const idx=Math.floor(Math.random()*drawingState.available.length);
                const winner=drawingState.available[idx];
                env.textContent=winner;
                env.classList.add('opened');

                drawingState.summary.push(`${drawCount}회차: ${winner}`);
                drawCount++;
                drawingResultBtn.style.display='inline-block';

                if(drawingState.allowDuplicates){
                    setTimeout(()=>{
                        envelopesContainer.querySelectorAll('.envelope').forEach(el=>{
                            el.textContent='?';
                            el.classList.remove('opened','is-opening');
                        });
                    },1500);
                }else{
                    drawingState.available.splice(idx,1);
                }

                drawingState.drawsLeft--;
                drawingStatusEl.textContent=`남은 횟수: ${drawingState.drawsLeft}`;
                if(drawingState.drawsLeft===0){
                    drawingStatusEl.textContent='뽑기 완료!';
                    setTimeout(()=>showResultModal('뽑기 결과',drawingState.summary),500);
                }
            },1000);
        });
        drawingResultBtn.addEventListener('click',()=>{
            if(drawingState.summary) showResultModal('뽑기 결과',drawingState.summary);
        });

        /* ---------------- 랜덤 숫자 뽑기 ---------------- */
        const numberPickerCanvas = document.getElementById('number-picker-canvas');
        const npCtx = numberPickerCanvas.getContext('2d');
        const generateNumbersButton = document.getElementById('generate-numbers-button');
        const pickNumberButton = document.getElementById('pick-number-button');
        let numberBalls = [];
        let numberPickerAnimationId = null;
        let numberPickerState = { picking: false, winner: null, phase: 'idle' }; // idle, mixing, announcing, finished

        function initNumberPicker() {
            if (numberPickerAnimationId) cancelAnimationFrame(numberPickerAnimationId);
            numberPickerAnimationId = null;

            numberBalls = [];
            numberPickerState = { picking: false, winner: null, phase: 'idle' };
            document.getElementById('number-picker-result').textContent = '';
            pickNumberButton.style.display = 'none';
            generateNumbersButton.textContent = '숫자판 생성';
            generateNumbersButton.disabled = false;
            pickNumberButton.disabled = false;
            
            drawNumberPicker();

            document.querySelectorAll('input[name="number-mode"]').forEach(radio => {
                radio.onchange = (e) => {
                    const isRange = e.target.value === 'range';
                    document.getElementById('number-range-container').style.display = isRange ? 'block' : 'none';
                    document.getElementById('number-direct-container').style.display = isRange ? 'none' : 'block';
                };
            });
        }

        function drawEnlargedWinner(winner) {
            const dpr = window.devicePixelRatio || 1;
            const width = numberPickerCanvas.width / dpr;
            const height = numberPickerCanvas.height / dpr;
            
            npCtx.fillStyle = '#EEE8D5';
            npCtx.fillRect(0, 0, width, height);

            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 3;

            npCtx.beginPath();
            npCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            npCtx.fillStyle = winner.color;
            npCtx.fill();
            npCtx.strokeStyle = PURE_WHITE;
            npCtx.lineWidth = 6;
            npCtx.stroke();

            npCtx.fillStyle = PURE_WHITE;
            npCtx.textAlign = 'center';
            npCtx.textBaseline = 'middle';
            const fontSize = radius * 0.7;
            npCtx.font = `${fontSize}px 'Press Start 2P'`;
            npCtx.fillText(winner.num, centerX, centerY + 4);
        }

        function drawNumberPicker() {
            const dpr = window.devicePixelRatio || 1;
            const width = numberPickerCanvas.width / dpr;
            const height = numberPickerCanvas.height / dpr;

            npCtx.fillStyle = '#EEE8D5';
            npCtx.fillRect(0, 0, width, height);
            
            numberBalls.forEach(ball => {
                npCtx.beginPath();
                npCtx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
                npCtx.fillStyle = ball.color;
                npCtx.fill();

                npCtx.fillStyle = PURE_WHITE;
                npCtx.textAlign = 'center';
                npCtx.textBaseline = 'middle';
                const fontSize = Math.max(10, ball.r * 0.7);
                npCtx.font = `${fontSize}px 'Press Start 2P'`;
                npCtx.fillText(ball.num, ball.x, ball.y + 2);
            });
            
            if (numberBalls.length === 0 && numberPickerState.phase === 'idle') {
                npCtx.font = "12px 'Press Start 2P'";
                npCtx.textAlign = 'center';
                npCtx.fillStyle = COLORS.font;
                npCtx.fillText("숫자 입력 후 생성", width / 2, height / 2 - 10);
                npCtx.fillText("버튼을 누르세요", width / 2, height / 2 + 15);
            }
        }

        function numberPickerLoop() {
            const dpr = window.devicePixelRatio || 1;
            const width = numberPickerCanvas.width / dpr;
            const height = numberPickerCanvas.height / dpr;

            if (numberPickerState.phase === 'announcing' && numberPickerState.winner) {
                const winner = numberPickerState.winner;
                const targetRadius = Math.min(width, height) / 3;
                
                winner.r += (targetRadius - winner.r) * 0.05;
                winner.x += (width/2 - winner.x) * 0.05;
                winner.y += (height/2 - winner.y) * 0.05;
                winner.vx *= 0.9;
                winner.vy *= 0.9;

                numberBalls.forEach(ball => {
                    if (ball.num === winner.num) return;
                    const dx = ball.x - winner.x;
                    const dy = ball.y - winner.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = ball.r + winner.r;
                    if (dist < minDist) {
                        const angle = Math.atan2(dy, dx);
                        ball.vx += Math.cos(angle) * 1.5;
                        ball.vy += Math.sin(angle) * 1.5;
                    }
                     // Move other balls off-screen
                    if (ball.x < width / 2) ball.vx -= 0.5; else ball.vx += 0.5;
                    if (ball.y < height / 2) ball.vy -= 0.5; else ball.vy += 0.5;
                });
            } else {
                 numberBalls.forEach(ball => {
                    ball.x += ball.vx;
                    ball.y += ball.vy;

                    if (ball.x - ball.r < 0) { ball.x = ball.r; ball.vx *= -1; }
                    if (ball.x + ball.r > width) { ball.x = width - ball.r; ball.vx *= -1; }
                    if (ball.y - ball.r < 0) { ball.y = ball.r; ball.vy *= -1; }
                    if (ball.y + ball.r > height) { ball.y = height - ball.r; ball.vy *= -1; }
                });
            }
            
            drawNumberPicker();
            numberPickerAnimationId = requestAnimationFrame(numberPickerLoop);
        }

        function parseNumbers() {
            const mode = document.querySelector('input[name="number-mode"]:checked').value;
            const numberSet = new Set();
            try {
                if (mode === 'range') {
                    const input = document.getElementById('number-range-input').value;
                    if (!input.trim()) return [];
                    input.split(',').forEach(rangeStr => {
                        const parts = rangeStr.trim().split('-');
                        if (parts.length > 2 || parts.length < 1 || (parts.length === 1 && !/^\d+$/.test(parts[0]))) throw new Error('잘못된 범위 형식입니다. (예: 1-10, 15)');
                        const start = parseInt(parts[0], 10);
                        const end = parts.length === 2 ? parseInt(parts[1], 10) : start;
                        if (isNaN(start) || isNaN(end) || start > end) throw new Error('범위가 올바르지 않습니다.');
                        for (let i = start; i <= end; i++) numberSet.add(i);
                    });
                } else {
                    const input = document.getElementById('number-direct-input').value;
                    if (!input.trim()) return [];
                    input.split(/[\s,]+/).forEach(numStr => {
                        if (numStr.trim()) {
                            const num = parseInt(numStr.trim(), 10);
                            if (isNaN(num)) throw new Error('숫자가 아닌 값이 포함되어 있습니다.');
                            numberSet.add(num);
                        }
                    });
                }
            } catch (error) {
                showResultModal('입력 오류', error.message);
                return null;
            }
            return Array.from(numberSet);
        }

        function generateNumbers() {
            const numbers = parseNumbers();
            if (!numbers) return;
            if (numbers.length < 2) {
                showResultModal('오류', '뽑을 숫자는 2개 이상이어야 합니다.');
                return;
            }

            if (numberPickerAnimationId) cancelAnimationFrame(numberPickerAnimationId);

            const dpr = window.devicePixelRatio || 1;
            const width = numberPickerCanvas.width / dpr;
            const height = numberPickerCanvas.height / dpr;
            const radius = Math.max(15, Math.min(30, (width / Math.sqrt(numbers.length)) * 0.8));

            numberBalls = numbers.map(num => ({
                num: num, r: radius,
                x: Math.random() * (width - radius * 2) + radius,
                y: Math.random() * (height - radius * 2) + radius,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                color: ROULETTE_COLORS[Math.floor(Math.random() * ROULETTE_COLORS.length)]
            }));
            
            numberPickerState = { picking: false, winner: null, phase: 'idle' };
            document.getElementById('number-picker-result').textContent = '';
            pickNumberButton.style.display = 'inline-block';
            pickNumberButton.disabled = false;
            generateNumbersButton.textContent = '재생성';
            numberPickerLoop();
        }

        function pickNumber() {
            if (numberBalls.length === 0 || numberPickerState.picking) return;

            numberPickerState.picking = true;
            numberPickerState.phase = 'mixing';
            const resultEl = document.getElementById('number-picker-result');

            pickNumberButton.disabled = true;
            generateNumbersButton.disabled = true;
            resultEl.textContent = '숫자를 뽑고 있습니다...';

            numberBalls.forEach(ball => {
                ball.vx *= (Math.random() * 1.5 + 2);
                ball.vy *= (Math.random() * 1.5 + 2);
            });

            setTimeout(() => {
                const winner = numberBalls[Math.floor(Math.random() * numberBalls.length)];
                numberPickerState.winner = winner;
                numberPickerState.phase = 'announcing';
                
                setTimeout(() => {
                    if (numberPickerAnimationId) cancelAnimationFrame(numberPickerAnimationId);
                    numberPickerAnimationId = null;
                    
                    numberPickerState.phase = 'finished';
                    drawEnlargedWinner(winner);
                    resultEl.textContent = `당첨 숫자: ${winner.num}`;
                    showResultModal('랜덤 숫자 뽑기 결과', `🎉 ${winner.num} 🎉`);
    
                    pickNumberButton.disabled = false;
                    generateNumbersButton.disabled = false;
                    numberPickerState.picking = false;
                }, 2500); // Announcing phase duration
            }, 2000); // Mixing phase duration
        }

        generateNumbersButton.addEventListener('click', generateNumbers);
        pickNumberButton.addEventListener('click', pickNumber);


        /* --- 리사이즈 & 초기화 --- */
        function resizeCanvases(){
            const canvases=document.querySelectorAll('.game-canvas');
            canvases.forEach(canvas=>{
                const container=canvas.parentElement;
                const style=getComputedStyle(container);
                const containerWidth=container.clientWidth-parseFloat(style.paddingLeft)-parseFloat(style.paddingRight);
                const dpr=window.devicePixelRatio||1;
                const aspect = canvas.id==='ladder-canvas' ? 0.75 : (canvas.id === 'number-picker-canvas' ? 0.65 : 1);

                canvas.style.width=containerWidth+'px';
                canvas.style.height=(containerWidth*aspect)+'px';
                canvas.width=Math.floor(containerWidth*dpr);
                canvas.height=Math.floor(containerWidth*aspect*dpr);
                const ctx=canvas.getContext('2d');
                ctx.setTransform(dpr,0,0,dpr,0,0);
            });
            if(document.getElementById('roulette-screen').classList.contains('active')) drawRoulette();
            if(document.getElementById('ladder-screen').classList.contains('active')) drawLadder();
            if(document.getElementById('number-picker-screen').classList.contains('active')) drawNumberPicker();
        }
        window.addEventListener('resize',resizeCanvases);
        document.addEventListener('DOMContentLoaded',()=>{ showScreen('main-menu'); });
    </script>
</body>
</html>

